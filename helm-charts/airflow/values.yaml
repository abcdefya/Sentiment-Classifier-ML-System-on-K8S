---
fullnameOverride: ""
nameOverride: ""
useStandardNaming: false
revisionHistoryLimit: ~
uid: 50000
gid: 0
securityContext: {}
securityContexts:
  pod: {}
  containers: {}
containerLifecycleHooks: {}
airflowHome: /opt/airflow
defaultAirflowRepository: apache/airflow
defaultAirflowTag: "3.0.2"
defaultAirflowDigest: ~
airflowVersion: "3.0.2"
images:
  airflow:
    repository: ~
    tag: ~
    digest: ~
    pullPolicy: IfNotPresent
  useDefaultImageForMigration: false
  migrationsWaitTimeout: 60
  pod_template:
    repository: ~
    tag: ~
    pullPolicy: IfNotPresent
  flower:
    repository: ~
    tag: ~
    pullPolicy: IfNotPresent
  statsd:
    repository: quay.io/prometheus/statsd-exporter
    tag: v0.28.0
    pullPolicy: IfNotPresent
  redis:
    repository: redis
    tag: 7.2-bookworm
    pullPolicy: IfNotPresent
  pgbouncer:
    repository: apache/airflow
    tag: airflow-pgbouncer-2025.03.05-1.23.1
    pullPolicy: IfNotPresent
  pgbouncerExporter:
    repository: apache/airflow
    tag: airflow-pgbouncer-exporter-2025.03.05-0.18.0
    pullPolicy: IfNotPresent
  gitSync:
    repository: registry.k8s.io/git-sync/git-sync
    tag: v4.3.0
    pullPolicy: IfNotPresent
nodeSelector: {}
affinity: {}
tolerations: []
topologySpreadConstraints: []
schedulerName: ~
labels: {}
ingress:
  enabled: ~
  apiServer:
    enabled: false
    annotations: {}
    path: "/"
    pathType: "ImplementationSpecific"
    host: ""
    hosts: []
    ingressClassName: ""
    tls:
      enabled: false
      secretName: ""
    precedingPaths: []
    succeedingPaths: []
  web:
    enabled: false
    annotations: {}
    path: "/"
    pathType: "ImplementationSpecific"
    host: ""
    hosts: []
    ingressClassName: ""
    tls:
      enabled: false
      secretName: ""
    precedingPaths: []
    succeedingPaths: []
  flower:
    enabled: false
    annotations: {}
    path: "/"
    pathType: "ImplementationSpecific"
    host: ""
    hosts: []
    ingressClassName: ""
    tls:
      enabled: false
      secretName: ""
  statsd:
    enabled: false
    annotations: {}
    path: "/metrics"
    pathType: "ImplementationSpecific"
    host: ""
    hosts: []
    ingressClassName: ""
  pgbouncer:
    enabled: false
    annotations: {}
    path: "/metrics"
    pathType: "ImplementationSpecific"
    host: ""
    hosts: []
    ingressClassName: ""
networkPolicies:
  enabled: false
airflowPodAnnotations: {}
airflowConfigAnnotations: {}
airflowLocalSettings: |-
  {{- if semverCompare ">=2.2.0 <3.0.0" .Values.airflowVersion }}
  {{- if not (or .Values.webserverSecretKey .Values.webserverSecretKeySecretName) }}
  from airflow.www.utils import UIAlert

  DASHBOARD_UIALERTS = [
    UIAlert(
      'Usage of a dynamic webserver secret key detected. We recommend a static webserver secret key instead.'
      ' See the <a href='
      '"https://airflow.apache.org/docs/helm-chart/stable/production-guide.html#webserver-secret-key" '
      'target="_blank" rel="noopener noreferrer">'
      'Helm Chart Production Guide</a> for more details.',
      category="warning",
      roles=["Admin"],
      html=True,
    )
  ]
  {{- end }}
  {{- end }}
rbac:
  create: true
  createSCCRoleBinding: false
executor: "CeleryExecutor"
allowPodLaunching: true
env: []
volumes: []
volumeMounts: []
secret: []
enableBuiltInSecretEnvVars:
  AIRFLOW__CORE__FERNET_KEY: true
  AIRFLOW__CORE__SQL_ALCHEMY_CONN: true
  AIRFLOW__DATABASE__SQL_ALCHEMY_CONN: true
  AIRFLOW_CONN_AIRFLOW_DB: true
  AIRFLOW__API__SECRET_KEY: true
  AIRFLOW__API_AUTH__JWT_SECRET: true
  AIRFLOW__WEBSERVER__SECRET_KEY: true
  AIRFLOW__CELERY__CELERY_RESULT_BACKEND: true
  AIRFLOW__CELERY__RESULT_BACKEND: true
  AIRFLOW__CELERY__BROKER_URL: true
  AIRFLOW__ELASTICSEARCH__HOST: true
  AIRFLOW__ELASTICSEARCH__ELASTICSEARCH_HOST: true
  AIRFLOW__OPENSEARCH__HOST: true
priorityClasses: []
extraSecrets: {}
extraConfigMaps: {}
extraEnv: ~
extraEnvFrom: ~
data:

  metadataSecretName: ~
  resultBackendSecretName: ~
  brokerUrlSecretName: ~
  metadataConnection:
    user: postgres
    pass: postgres
    protocol: postgresql
    host: ~
    port: 5432
    db: postgres
    sslmode: disable
    secretAnnotations: {}
  resultBackendConnection: ~
  resultBackendConnectionSecretAnnotations: {}
  brokerUrl: ~
  brokerUrlSecretAnnotations: {}
fernetKey: ~
fernetKeySecretName: ~
fernetKeySecretAnnotations: {}
apiSecretKey: ~
apiSecretAnnotations: {}
apiSecretKeySecretName: ~
jwtSecret: ~
jwtSecretAnnotations: {}
jwtSecretName: ~
webserverSecretKey: ~
webserverSecretAnnotations: {}
webserverSecretKeySecretName: ~

kerberos:
  enabled: false
  ccacheMountPath: /var/kerberos-ccache
  ccacheFileName: cache
  configPath: /etc/krb5.conf
  keytabBase64Content: ~
  keytabPath: /etc/airflow.keytab
  principal: airflow@FOO.COM
  reinitFrequency: 3600
  config: |

    [logging]
    default = "FILE:{{ template "airflow_logs_no_quote" . }}/kerberos_libs.log"
    kdc = "FILE:{{ template "airflow_logs_no_quote" . }}/kerberos_kdc.log"
    admin_server = "FILE:{{ template "airflow_logs_no_quote" . }}/kadmind.log"

    [libdefaults]
    default_realm = FOO.COM
    ticket_lifetime = 10h
    renew_lifetime = 7d
    forwardable = true

    [realms]
    FOO.COM = {
      kdc = kdc-server.foo.com
      admin_server = admin_server.foo.com
    }
workers:
  replicas: 1
  revisionHistoryLimit: ~
  command: ~
  args:
    - "bash"
    - "-c"
    - |-
      exec \
      airflow {{ semverCompare ">=2.0.0" .Values.airflowVersion | ternary "celery worker" "worker" }}
  livenessProbe:
    enabled: true
    initialDelaySeconds: 10
    timeoutSeconds: 20
    failureThreshold: 5
    periodSeconds: 60
    command: ~
  updateStrategy: ~
  strategy:
    rollingUpdate:
      maxSurge: "100%"
      maxUnavailable: "50%"
  securityContext: {}
  securityContexts:
    pod: {}
    container: {}
  containerLifecycleHooks: {}
  serviceAccount:
    automountServiceAccountToken: true
    create: true
    name: ~
    annotations: {}
  keda:
    enabled: false
    namespaceLabels: {}
    pollingInterval: 5
    cooldownPeriod: 30
    minReplicaCount: 0
    maxReplicaCount: 10
    advanced: {}
    query: >-
      SELECT ceil(COUNT(*)::decimal / {{ .Values.config.celery.worker_concurrency }})
      FROM task_instance
      WHERE (state='running' OR state='queued')
      {{- if or (contains "CeleryKubernetesExecutor" .Values.executor)
      (contains "KubernetesExecutor" .Values.executor) }}
      AND queue != '{{ .Values.config.celery_kubernetes_executor.kubernetes_queue }}'
      {{- end }}
    usePgbouncer: true
  hpa:
    enabled: false
    minReplicaCount: 0
    maxReplicaCount: 5
    metrics:
      - type: Resource
        resource:
          name: cpu
          target:
            type: Utilization
            averageUtilization: 80
    behavior: {}
  persistence:
    enabled: true
    persistentVolumeClaimRetentionPolicy: ~
    size: 5Gi #100Gi
    storageClassName:
    fixPermissions: false
    annotations: {}
    securityContexts:
      container: {}
    containerLifecycleHooks: {}
  kerberosSidecar:
    enabled: false

    resources: {}
    securityContexts:
      container: {}
    containerLifecycleHooks: {}
  kerberosInitContainer:
    enabled: false
    resources: {}
    securityContexts:
      container: {}
    containerLifecycleHooks: {}
  resources: {}
  terminationGracePeriodSeconds: 600
  safeToEvict: false
  extraContainers: []
  extraInitContainers: []
  extraVolumes: []
  extraVolumeMounts: []
  extraPorts: []
  nodeSelector: {}
  runtimeClassName: ~
  priorityClassName: ~
  affinity: {}
  tolerations: []
  topologySpreadConstraints: []
  hostAliases: []
  annotations: {}
  podAnnotations: {}
  labels: {}
  logGroomerSidecar:
    enabled: true
    command: ~
    args: ["bash", "/clean-logs"]
    retentionDays: 15
    frequencyMinutes: 15

    resources: {}
    securityContexts:
      container: {}

    env: []
  waitForMigrations:
    enabled: true

    env: []
    securityContexts:
      container: {}
  env: []
  volumeClaimTemplates: []
scheduler:
  enabled: true
  hostAliases: []
  livenessProbe:
    initialDelaySeconds: 10
    timeoutSeconds: 20
    failureThreshold: 5
    periodSeconds: 60
    command: ~
  startupProbe:
    initialDelaySeconds: 0
    failureThreshold: 6
    periodSeconds: 10
    timeoutSeconds: 20
    command: ~
  replicas: 1
  revisionHistoryLimit: ~
  command: ~
  args: ["bash", "-c", "exec airflow scheduler"]
  updateStrategy: ~
  strategy: ~
  securityContext: {}
  securityContexts:
    pod: {}
    container: {}
  containerLifecycleHooks: {}
  terminationGracePeriodSeconds: 10
  serviceAccount:
    automountServiceAccountToken: true
    create: true
    name: ~
    annotations: {}
  podDisruptionBudget:
    enabled: false
    config:
      maxUnavailable: 1

  resources: {}
  safeToEvict: true
  extraContainers: []
  extraInitContainers: []
  extraVolumes: []
  extraVolumeMounts: []
  nodeSelector: {}
  affinity: {}
  tolerations: []
  topologySpreadConstraints: []

  priorityClassName: ~
  annotations: {}

  podAnnotations: {}
  labels: {}

  logGroomerSidecar:
    enabled: true
    command: ~
    args: ["bash", "/clean-logs"]
    retentionDays: 15
    frequencyMinutes: 15
    resources: {}
    securityContexts:
      container: {}
    containerLifecycleHooks: {}
    env: []

  waitForMigrations:
    enabled: true
    env: []
    securityContexts:
      container: {}

  env: []
createUserJob:
  ttlSecondsAfterFinished: 300
  command: ~
  args:
    - "bash"
    - "-c"
    - |-
      exec \
      airflow {{ semverCompare ">=2.0.0" .Values.airflowVersion | ternary "users create" "create_user" }} "$@"
    - --
    - "-r"
    - "{{ .Values.webserver.defaultUser.role }}"
    - "-u"
    - "{{ .Values.webserver.defaultUser.username }}"
    - "-e"
    - "{{ .Values.webserver.defaultUser.email }}"
    - "-f"
    - "{{ .Values.webserver.defaultUser.firstName }}"
    - "-l"
    - "{{ .Values.webserver.defaultUser.lastName }}"
    - "-p"
    - "{{ .Values.webserver.defaultUser.password }}"
  annotations: {}
  jobAnnotations: {}
  labels: {}
  securityContext: {}
  securityContexts:
    pod: {}
    container: {}
  containerLifecycleHooks: {}
  serviceAccount:
    automountServiceAccountToken: true
    create: true
    name: ~
    annotations: {}
  extraContainers: []
  extraInitContainers: []
  extraVolumes: []
  extraVolumeMounts: []

  nodeSelector: {}
  affinity: {}
  tolerations: []
  topologySpreadConstraints: []
  priorityClassName: ~
  useHelmHooks: true
  applyCustomEnv: true

  env: []

  resources: {}
migrateDatabaseJob:
  enabled: true
  ttlSecondsAfterFinished: 300
  command: ~
  args:
    - "bash"
    - "-c"
    - >-
      exec \

      airflow {{ semverCompare ">=2.7.0" .Values.airflowVersion
      | ternary "db migrate" (semverCompare ">=2.0.0" .Values.airflowVersion
      | ternary "db upgrade" "upgradedb") }}
  annotations: {}
  jobAnnotations: {}
  labels: {}
  securityContext: {}
  securityContexts:
    pod: {}
    container: {}
  containerLifecycleHooks: {}
  serviceAccount:
    automountServiceAccountToken: true
    create: true
    name: ~
    annotations: {}

  resources: {}
  extraContainers: []
  extraInitContainers: []
  extraVolumes: []
  extraVolumeMounts: []

  nodeSelector: {}
  affinity: {}
  tolerations: []
  topologySpreadConstraints: []
  priorityClassName: ~
  useHelmHooks: true
  applyCustomEnv: true
  env: []

apiServer:
  replicas: 1
  revisionHistoryLimit: ~
  labels: {}
  command: ~
  args: ["bash", "-c", "exec airflow api-server"]
  allowPodLogReading: true
  env: []
  serviceAccount:
    automountServiceAccountToken: true
    create: true
    name: ~
    annotations: {}
  service:
    type: ClusterIP
    annotations: {}
    ports:
      - name: api-server
        port: "{{ .Values.ports.apiServer }}"

    loadBalancerIP: ~
    loadBalancerSourceRanges: []

  podDisruptionBudget:
    enabled: false
    config:
      maxUnavailable: 1
  strategy: ~
  securityContexts:
    pod: {}
    container: {}
  containerLifecycleHooks: {}

  waitForMigrations:
    enabled: true
    env: []
    securityContexts:
      container: {}
  extraContainers: []
  extraInitContainers: []
  extraVolumes: []
  extraVolumeMounts: []
  nodeSelector: {}
  affinity: {}
  tolerations: []
  topologySpreadConstraints: []

  priorityClassName: ~
  hostAliases: []
  annotations: {}

  podAnnotations: {}

  networkPolicy:
    ingress:
      from: []
      ports:
        - port: "{{ .Values.ports.apiServer }}"

  resources: {}
  configMapAnnotations: {}
  apiServerConfig: ~
  apiServerConfigConfigMapName: ~

  livenessProbe:
    initialDelaySeconds: 15
    timeoutSeconds: 5
    failureThreshold: 5
    periodSeconds: 10
    scheme: HTTP

  readinessProbe:
    initialDelaySeconds: 15
    timeoutSeconds: 5
    failureThreshold: 5
    periodSeconds: 10
    scheme: HTTP

  startupProbe:
    initialDelaySeconds: 0
    timeoutSeconds: 20
    failureThreshold: 6
    periodSeconds: 10
    scheme: HTTP
webserver:
  enabled: true
  configMapAnnotations: {}
  hostAliases: []
  allowPodLogReading: true
  livenessProbe:
    initialDelaySeconds: 15
    timeoutSeconds: 5
    failureThreshold: 5
    periodSeconds: 10
    scheme: HTTP

  readinessProbe:
    initialDelaySeconds: 15
    timeoutSeconds: 5
    failureThreshold: 5
    periodSeconds: 10
    scheme: HTTP
  startupProbe:
    initialDelaySeconds: 0
    timeoutSeconds: 20
    failureThreshold: 6
    periodSeconds: 10
    scheme: HTTP
  replicas: 1
  revisionHistoryLimit: ~
  command: ~
  args: ["bash", "-c", "exec airflow webserver"]
  terminationGracePeriodSeconds: 30
  hpa:
    enabled: false
    minReplicaCount: 1
    maxReplicaCount: 5
    metrics:
      - type: Resource
        resource:
          name: cpu
          target:
            type: Utilization
            averageUtilization: 80
    behavior: {}
  serviceAccount:
    automountServiceAccountToken: true
    create: true
    name: ~
    annotations: {}
  podDisruptionBudget:
    enabled: false
    config:
      maxUnavailable: 1
  strategy: ~
  securityContext: {}
  securityContexts:
    pod: {}
    container: {}
  containerLifecycleHooks: {}
  extraNetworkPolicies: []
  networkPolicy:
    ingress:
      from: []
      ports:
        - port: "{{ .Values.ports.airflowUI }}"

  resources: {}
  defaultUser:
    enabled: true
    role: Admin
    username: admin
    email: admin@example.com
    firstName: admin
    lastName: user
    password: admin
  extraContainers: []
  extraInitContainers: []
  extraVolumes: []
  extraVolumeMounts: []
  webserverConfig: ~
  webserverConfigConfigMapName: ~

  service:
    type: ClusterIP
    annotations: {}
    ports:
      - name: airflow-ui
        port: "{{ .Values.ports.airflowUI }}"
    loadBalancerIP: ~
    loadBalancerSourceRanges: []
  nodeSelector: {}
  priorityClassName: ~
  affinity: {}
  tolerations: []
  topologySpreadConstraints: []
  annotations: {}

  podAnnotations: {}
  labels: {}

  waitForMigrations:
    enabled: true
    env: []
    securityContexts:
      container: {}

  env: []
triggerer:
  enabled: true
  replicas: 1
  revisionHistoryLimit: ~
  command: ~
  args: ["bash", "-c", "exec airflow triggerer"]
  updateStrategy: ~
  strategy:
    rollingUpdate:
      maxSurge: "100%"
      maxUnavailable: "50%"
  livenessProbe:
    initialDelaySeconds: 10
    timeoutSeconds: 20
    failureThreshold: 5
    periodSeconds: 60
    command: ~
  serviceAccount:
    automountServiceAccountToken: true
    create: true
    name: ~
    annotations: {}
  securityContext: {}
  securityContexts:
    pod: {}
    container: {}
  containerLifecycleHooks: {}

  persistence:
    enabled: true
    persistentVolumeClaimRetentionPolicy: ~
    size: 5Gi #100Gi
    storageClassName:
    fixPermissions: false
    annotations: {}

  resources: {}
  terminationGracePeriodSeconds: 60
  safeToEvict: true
  extraContainers: []
  extraInitContainers: []
  extraVolumes: []
  extraVolumeMounts: []
  nodeSelector: {}
  affinity: {}
  tolerations: []
  topologySpreadConstraints: []
  hostAliases: []

  priorityClassName: ~
  annotations: {}

  podAnnotations: {}
  labels: {}

  logGroomerSidecar:
    enabled: true
    command: ~
    args: ["bash", "/clean-logs"]
    retentionDays: 15
    frequencyMinutes: 15
    resources: {}
    securityContexts:
      container: {}
    containerLifecycleHooks: {}

    env: []

  waitForMigrations:
    enabled: true
    env: []
    securityContexts:
      container: {}

  env: []
  keda:
    enabled: false
    namespaceLabels: {}
    pollingInterval: 5
    cooldownPeriod: 30
    minReplicaCount: 0
    maxReplicaCount: 10
    advanced: {}
    query: >-
      SELECT ceil(COUNT(*)::decimal / {{ include "triggerer.capacity" . }})
      FROM trigger
    usePgbouncer: false
dagProcessor:
  enabled: ~
  replicas: 1
  revisionHistoryLimit: ~
  command: ~
  args: ["bash", "-c", "exec airflow dag-processor"]
  strategy:
    rollingUpdate:
      maxSurge: "100%"
      maxUnavailable: "50%"
  livenessProbe:
    initialDelaySeconds: 10
    timeoutSeconds: 20
    failureThreshold: 5
    periodSeconds: 60
    command: ~
  serviceAccount:
    automountServiceAccountToken: true
    create: true
    name: ~
    annotations: {}
  securityContext: {}
  securityContexts:
    pod: {}
    container: {}
  containerLifecycleHooks: {}

  resources: {}
  terminationGracePeriodSeconds: 60
  safeToEvict: true
  extraContainers: []
  extraInitContainers: []
  extraVolumes: []
  extraVolumeMounts: []
  nodeSelector: {}
  affinity: {}
  tolerations: []
  topologySpreadConstraints: []

  priorityClassName: ~
  annotations: {}

  podAnnotations: {}

  logGroomerSidecar:
    enabled: true
    command: ~
    args: ["bash", "/clean-logs"]
    retentionDays: 15
    frequencyMinutes: 15
    resources: {}
    securityContexts:
      container: {}

    env: []

  waitForMigrations:
    enabled: true
    env: []
    securityContexts:
      container: {}

  env: []
flower:
  enabled: false

  livenessProbe:
    initialDelaySeconds: 10
    timeoutSeconds: 5
    failureThreshold: 10
    periodSeconds: 5

  readinessProbe:
    initialDelaySeconds: 10
    timeoutSeconds: 5
    failureThreshold: 10
    periodSeconds: 5
  startupProbe:
    initialDelaySeconds: 0
    timeoutSeconds: 20
    failureThreshold: 6
    periodSeconds: 10
  revisionHistoryLimit: ~
  command: ~
  args:
    - "bash"
    - "-c"
    - |-
      exec \
      airflow {{ semverCompare ">=2.0.0" .Values.airflowVersion | ternary "celery flower" "flower" }}
  extraNetworkPolicies: []
  networkPolicy:
    ingress:
      from: []
      ports:
        - port: "{{ .Values.ports.flowerUI }}"

  resources: {}
  securityContext: {}
  securityContexts:
    pod: {}
    container: {}
  containerLifecycleHooks: {}
  serviceAccount:
    automountServiceAccountToken: true
    create: true
    name: ~
    annotations: {}
  secretName: ~
  secretAnnotations: {}
  username: ~
  password: ~

  service:
    type: ClusterIP
    annotations: {}
    ports:
      - name: flower-ui
        port: "{{ .Values.ports.flowerUI }}"
    loadBalancerIP: ~
    loadBalancerSourceRanges: []
  extraContainers: []
  extraVolumes: []
  extraVolumeMounts: []
  nodeSelector: {}
  affinity: {}
  tolerations: []
  topologySpreadConstraints: []

  priorityClassName: ~
  annotations: {}

  podAnnotations: {}
  labels: {}
  env: []
statsd:
  configMapAnnotations: {}

  enabled: true
  revisionHistoryLimit: ~
  args: ["--statsd.mapping-config=/etc/statsd-exporter/mappings.yml"]
  annotations: {}
  terminationGracePeriodSeconds: 30
  serviceAccount:
    automountServiceAccountToken: true
    create: true
    name: ~
    annotations: {}

  uid: 65534
  securityContext: {}
  securityContexts:
    pod: {}
    container: {}
  containerLifecycleHooks: {}
  extraNetworkPolicies: []
  resources: {}

  service:
    extraAnnotations: {}
  nodeSelector: {}
  affinity: {}
  tolerations: []
  topologySpreadConstraints: []

  priorityClassName: ~
  extraMappings: []
  overrideMappings: []

  podAnnotations: {}
  env: []
pgbouncer:
  enabled: false
  replicas: 1
  revisionHistoryLimit: ~
  command: ["pgbouncer", "-u", "nobody", "/etc/pgbouncer/pgbouncer.ini"]
  args: ~
  auth_type: scram-sha-256
  auth_file: /etc/pgbouncer/users.txt
  mountConfigSecret: true
  annotations: {}

  podAnnotations: {}
  certificatesSecretAnnotations: {}
  serviceAccount:
    automountServiceAccountToken: true
    create: true
    name: ~
    annotations: {}
  extraNetworkPolicies: []
  metadataPoolSize: 10
  resultBackendPoolSize: 5
  maxClientConn: 100
  configSecretName: ~
  configSecretAnnotations: {}
  podDisruptionBudget:
    enabled: false
    config:
      maxUnavailable: 1
  resources: {}

  service:
    extraAnnotations: {}
    clusterIp: ~
  verbose: 0
  logDisconnections: 0
  logConnections: 0

  sslmode: "prefer"
  ciphers: "normal"

  ssl:
    ca: ~
    cert: ~
    key: ~
  extraIniMetadata: ~
  extraIniResultBackend: ~
  extraIni: ~
  extraVolumes: []
  extraVolumeMounts: []
  extraContainers: []
  nodeSelector: {}
  affinity: {}
  tolerations: []
  topologySpreadConstraints: []

  priorityClassName: ~

  uid: 65534
  securityContexts:
    pod: {}
    container: {}
  containerLifecycleHooks:
    preStop:
      exec:
        command: ["/bin/sh", "-c", "killall -INT pgbouncer && sleep 120"]

  metricsExporterSidecar:
    resources: {}
    sslmode: "disable"
    statsSecretName: ~
    statsSecretKey: ~
    statsSecretAnnotations: {}
    securityContexts:
      container: {}
    containerLifecycleHooks: {}

    livenessProbe:
      initialDelaySeconds: 10
      periodSeconds: 10
      timeoutSeconds: 1

    readinessProbe:
      initialDelaySeconds: 10
      periodSeconds: 10
      timeoutSeconds: 1
    extraVolumeMounts: []
  labels: {}
  env: []
redis:
  enabled: true
  terminationGracePeriodSeconds: 600
  annotations: {}
  serviceAccount:
    automountServiceAccountToken: true
    create: true
    name: ~
    annotations: {}

  service:
    type: "ClusterIP"
    clusterIP:
    nodePort:

  persistence:
    enabled: true
    size: 1Gi
    storageClassName:
    annotations: {}
    existingClaim:

  resources: {}
  passwordSecretName: ~
  password: ~
  passwordSecretAnnotations: {}
  safeToEvict: true
  nodeSelector: {}
  affinity: {}
  tolerations: []
  topologySpreadConstraints: []
  priorityClassName: ~
  uid: 0
  securityContext: {}
  securityContexts:
    pod: {}
    container: {}
  containerLifecycleHooks: {}

  podAnnotations: {}
registry:
  secretName: ~
  connection: {}
elasticsearch:
  enabled: false
  secretName: ~
  secretAnnotations: {}
  connection: {}
opensearch:
  enabled: false
  secretName: ~
  connection: {}
ports:
  flowerUI: 5555
  airflowUI: 8080
  workerLogs: 8793
  triggererLogs: 8794
  redisDB: 6379
  statsdIngest: 9125
  statsdScrape: 9102
  pgbouncer: 6543
  pgbouncerScrape: 9127
  apiServer: 8080
quotas: {}
limits: []
cleanup:
  enabled: false
  schedule: "*/15 * * * *"
  command: ~
  args: ["bash", "-c", "exec airflow kubernetes cleanup-pods --namespace={{ .Release.Namespace }}"]
  jobAnnotations: {}
  nodeSelector: {}
  affinity: {}
  tolerations: []
  topologySpreadConstraints: []
  priorityClassName: ~

  podAnnotations: {}
  labels: {}

  resources: {}
  serviceAccount:
    automountServiceAccountToken: true
    create: true
    name: ~
    annotations: {}
  securityContext: {}
  env: []
  securityContexts:
    pod: {}
    container: {}
  containerLifecycleHooks: {}
  failedJobsHistoryLimit: ~
  successfulJobsHistoryLimit: ~
postgresql:
  enabled: true
  auth:
    enablePostgresUser: true
    postgresPassword: postgres
    username: ""
    password: ""
config:
  core:
    dags_folder: '{{ include "airflow_dags" . }}'
    load_examples: 'False'
    executor: '{{ .Values.executor }}'
    colored_console_log: 'False'
    remote_logging: '{{- ternary "True" "False" (or .Values.elasticsearch.enabled .Values.opensearch.enabled) }}'
    auth_manager: "airflow.providers.fab.auth_manager.fab_auth_manager.FabAuthManager"
  logging:
    remote_logging: '{{- ternary "True" "False" (or .Values.elasticsearch.enabled .Values.opensearch.enabled) }}'
    colored_console_log: 'False'
  metrics:
    statsd_on: '{{ ternary "True" "False" .Values.statsd.enabled }}'
    statsd_port: 9125
    statsd_prefix: airflow
    statsd_host: '{{ printf "%s-statsd" (include "airflow.fullname" .) }}'
  fab:
    enable_proxy_fix: 'True'
  webserver:
    enable_proxy_fix: 'True'
    rbac: 'True'
  celery:
    flower_url_prefix: '{{ ternary "" .Values.ingress.flower.path (eq .Values.ingress.flower.path "/") }}'
    worker_concurrency: 16
  scheduler:
    standalone_dag_processor: '{{ ternary "True" "False" (or (semverCompare ">=3.0.0" .Values.airflowVersion) (.Values.dagProcessor.enabled | default false)) }}'
    statsd_on: '{{ ternary "True" "False" .Values.statsd.enabled }}'
    statsd_port: 9125
    statsd_prefix: airflow
    statsd_host: '{{ printf "%s-statsd" (include "airflow.fullname" .) }}'
    run_duration: 41460
  elasticsearch:
    json_format: 'True'
    log_id_template: "{dag_id}_{task_id}_{execution_date}_{try_number}"
  elasticsearch_configs:
    max_retries: 3
    timeout: 30
    retry_timeout: 'True'
  kerberos:
    keytab: '{{ .Values.kerberos.keytabPath }}'
    reinit_frequency: '{{ .Values.kerberos.reinitFrequency }}'
    principal: '{{ .Values.kerberos.principal }}'
    ccache: '{{ .Values.kerberos.ccacheMountPath }}/{{ .Values.kerberos.ccacheFileName }}'
  celery_kubernetes_executor:
    kubernetes_queue: 'kubernetes'
  kubernetes:
    namespace: '{{ .Release.Namespace }}'
    airflow_configmap: '{{ include "airflow_config" . }}'
    airflow_local_settings_configmap: '{{ include "airflow_config" . }}'
    pod_template_file: '{{ include "airflow_pod_template_file" . }}/pod_template_file.yaml'
    worker_container_repository: '{{ .Values.images.airflow.repository | default .Values.defaultAirflowRepository }}'
    worker_container_tag: '{{ .Values.images.airflow.tag | default .Values.defaultAirflowTag }}'
    multi_namespace_mode: '{{ ternary "True" "False" .Values.multiNamespaceMode }}'
  kubernetes_executor:
    namespace: '{{ .Release.Namespace }}'
    pod_template_file: '{{ include "airflow_pod_template_file" . }}/pod_template_file.yaml'
    worker_container_repository: '{{ .Values.images.airflow.repository | default .Values.defaultAirflowRepository }}'
    worker_container_tag: '{{ .Values.images.airflow.tag | default .Values.defaultAirflowTag }}'
    multi_namespace_mode: '{{ ternary "True" "False" .Values.multiNamespaceMode }}'
multiNamespaceMode: false
podTemplate: ~
dags:
  mountPath: ~
  persistence:
    annotations: {}
    enabled: false
    size: 1Gi
    storageClassName:
    accessMode: ReadWriteOnce
    existingClaim:
    subPath: ~
  gitSync:
    enabled: false
    repo: https://github.com/apache/airflow.git
    branch: v2-2-stable
    rev: HEAD
    ref: v2-2-stable
    depth: 1
    maxFailures: 0
    subPath: "tests/dags"
    period: 5s
    wait: ~
    envFrom: ~

    containerName: git-sync
    uid: 65533
    securityContext: {}

    securityContexts:
      container: {}
    containerLifecycleHooks: {}
    extraVolumeMounts: []
    env: []

    resources: {}

logs:

  persistence:
    enabled: false
    size: 3Gi #100Gi
    annotations: {}
    storageClassName:
    existingClaim:
